// Path: src/generator/generators/projectFilesGenerator.ts
// Generator for project configuration files

import { BaseGenerator } from './baseGenerator';
import { MappedService, GeneratorOptions } from '../../types';
import { logger, LogCategory } from '../../utils/logger';
import { performance } from '../../utils/performanceUtils';
import * as path from 'path';

/**
 * Generator for project configuration files
 */
export class ProjectFilesGenerator extends BaseGenerator {
  /**
   * Generate project files (package.json, tsconfig.json, etc.)
   */
  public async generate(
    mappedService: MappedService, 
    options: GeneratorOptions
  ): Promise<void> {
    return performance.track('generate-project-files', async () => {
      logger.info('Generating project files...', LogCategory.GENERATOR);

      // Initialize the generator
      await this.initialize(options);

      // Prepare template data
      const templateData = this.createBaseTemplateData({
        service: mappedService,
        config: {
          projectName: mappedService.name.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
          author: process.env.USER || 'MCP Generator User',
          version: '0.1.0',
          description: `MCP server for ${mappedService.name}`,
          license: 'MIT'
        }
      });

      // Generate package.json
      await this.generatePackageJson(mappedService, options, templateData);

      // Generate tsconfig.json
      await this.generateTsConfig(options, templateData);

      // Generate README.md
      await this.generateReadme(mappedService, options, templateData);
    });
  }

  /**
   * Generate package.json file
   */
  private async generatePackageJson(
    mappedService: MappedService,
    options: GeneratorOptions,
    templateData: Record<string, any>
  ): Promise<void> {
    const packageJsonPath = path.join(options.outputDir, 'package.json');
    
    try {
      // Try to use template
      await this.renderTemplate('package.json', packageJsonPath, templateData);
      logger.success('Generated package.json', LogCategory.GENERATOR);
    } catch (error) {
      // Create a minimal package.json
      const packageJson = {
        name: mappedService.name.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
        version: '0.1.0',
        description: `MCP server for ${mappedService.name}`,
        main: 'dist/index.js',
        scripts: {
          build: 'tsc',
          start: 'node dist/index.js',
          dev: 'ts-node src/index.ts'
        },
        dependencies: {
          express: '^4.18.2',
          uuid: '^9.0.0'
        },
        devDependencies: {
          typescript: '^5.0.0',
          '@types/express': '^4.17.17',
          '@types/node': '^18.0.0',
          '@types/uuid': '^9.0.0',
          'ts-node': '^10.9.1'
        }
      };
      
      this.generateBasicFile(
        packageJsonPath,
        JSON.stringify(packageJson, null, 2)
      );
      
      logger.success('Generated basic package.json', LogCategory.GENERATOR);
    }
  }

  /**
   * Generate tsconfig.json file
   */
  private async generateTsConfig(
    options: GeneratorOptions,
    templateData: Record<string, any>
  ): Promise<void> {
    const tsconfigPath = path.join(options.outputDir, 'tsconfig.json');
    
    try {
      // Try to use template
      await this.renderTemplate('tsconfig.json', tsconfigPath, templateData);
      logger.success('Generated tsconfig.json', LogCategory.GENERATOR);
    } catch (error) {
      // Create a minimal tsconfig.json
      const tsconfig = {
        compilerOptions: {
          target: 'ES2020',
          module: 'commonjs',
          esModuleInterop: true,
          strict: true,
          skipLibCheck: true,
          outDir: './dist',
          sourceMap: true
        },
        include: ['**/*.ts'],
        exclude: ['node_modules']
      };
      
      this.generateBasicFile(
        tsconfigPath,
        JSON.stringify(tsconfig, null, 2)
      );
      
      logger.success('Generated basic tsconfig.json', LogCategory.GENERATOR);
    }
  }

  /**
   * Generate README.md file
   */
  private async generateReadme(
    mappedService: MappedService,
    options: GeneratorOptions,
    templateData: Record<string, any>
  ): Promise<void> {
    const readmePath = path.join(options.outputDir, 'README.md');
    
    try {
      // Try to use template
      await this.renderTemplate('README.md', readmePath, templateData);
      logger.success('Generated README.md', LogCategory.GENERATOR);
    } catch (error) {
      // Create a minimal README.md
      const readme = `# ${mappedService.name} MCP Server

Generated by Axe Handle MCP Server Generator

## Getting Started

### Installation

\`\`\`bash
npm install
\`\`\`

### Running the Server

\`\`\`bash
# Development
npm run dev

# Production
npm run build
npm start
\`\`\`
`;
      
      this.generateBasicFile(readmePath, readme);
      logger.success('Generated basic README.md', LogCategory.GENERATOR);
    }
  }
}