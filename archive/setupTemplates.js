"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
// Path: src/setupTemplates.ts
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
// Make sure we're getting the right project directory
const projectDir = path.resolve(__dirname, '..');
console.log('Project directory:', projectDir);
// This should be the correct templates directory
const templatesDir = path.join(projectDir, 'templates');
console.log('Templates directory:', templatesDir);
// Create the templates directory if it doesn't exist
if (!fs.existsSync(templatesDir)) {
    console.log('Creating templates directory...');
    fs.mkdirSync(templatesDir, { recursive: true });
}
// Create essential template files
const essentialTemplates = {
    'server.ejs': `// Generated by Axe Handle MCP Server Generator
// Date: <%= date %>
// Version: <%= version %>

import express from 'express';
import { json, urlencoded } from 'express';
import expressWs from 'express-ws';
import http from 'http';
import WebSocket from 'ws';
import { v4 as uuidv4 } from 'uuid';
import { logger } from './utils';

// Create Express application
const app = express();
const server = http.createServer(app);
const wsInstance = expressWs(app, server);

// Middleware
app.use(json());
app.use(urlencoded({ extended: true }));

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok' });
});

<% for (const resource of service.resources) { %>
// <%= resource.name %> endpoints
<% for (const operation of resource.operations) { %>
app.<%= operation.httpMethod.toLowerCase() %>('<%= operation.route %>', <%= resource.name.toLowerCase() %>Handler.<%= operation.name.toLowerCase() %><%= resource.name %>);
<% } %>

<% } %>

// WebSocket endpoint for MCP
app.ws('/mcp', (ws, req) => {
  const connectionId = uuidv4();
  logger.info(\`New MCP connection established: \${connectionId}\`);
  
  // Set up event handlers
  ws.on('message', (message) => {
    // Handle MCP messages
    try {
      const data = JSON.parse(message.toString());
      // TODO: Process the message
    } catch (error) {
      logger.error(\`Error processing message: \${error}\`);
    }
  });
  
  ws.on('close', () => {
    logger.info(\`MCP connection closed: \${connectionId}\`);
  });
  
  ws.on('error', (error) => {
    logger.error(\`MCP connection error: \${error}\`);
  });
});

export default app;`,
    'handler.ejs': `// Generated by Axe Handle MCP Server Generator
// Date: <%= date %>
// Version: <%= version %>

// Handler template for resources
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import {
  <%= resource.name %>,
<% for (const operation of resource.operations) { %>
  <%= operation.inputType %>,
<% if (operation.name === 'List' || operation.name === 'Delete') { %>
  <%= operation.outputType %>,
<% } %>
<% } %>
  McpErrorResponse
} from '../types';

// In-memory store for <%= resource.name %> resources (replace with a database in production)
const <%= resource.name.toLowerCase() %>Store: Record<string, <%= resource.name %>> = {};

/**
 * Handler for getting a <%= resource.name %> by ID.
 * @param req Express request
 * @param res Express response
 */
export async function get<%= resource.name %>(req: Request, res: Response): Promise<void> {
  try {
    const id = req.params.id;
    
    // Validate input
    if (!id) {
      const errorResponse: McpErrorResponse = {
        code: 'MCP-4000',
        message: 'Missing required parameter: id',
      };
      res.status(400).json(errorResponse);
      return;
    }
    
    // Get <%= resource.name %> from store
    const <%= resource.name.toLowerCase() %> = <%= resource.name.toLowerCase() %>Store[id];
    if (!<%= resource.name.toLowerCase() %>) {
      const errorResponse: McpErrorResponse = {
        code: 'MCP-4004',
        message: '<%= resource.name %> not found',
        details: { id }
      };
      res.status(404).json(errorResponse);
      return;
    }
    
    // Return the <%= resource.name %>
    res.status(200).json(<%= resource.name.toLowerCase() %>);
  } catch (error) {
    console.error(\`Error getting <%= resource.name.toLowerCase() %>:\`, error);
    const errorResponse: McpErrorResponse = {
      code: 'MCP-5000',
      message: 'Internal server error',
    };
    res.status(500).json(errorResponse);
  }
}

/**
 * Handler for listing <%= resource.name.toLowerCase() %>s.
 * @param req Express request
 * @param res Express response
 */
export async function list<%= resource.name %>s(req: Request, res: Response): Promise<void> {
  try {
    // Get query parameters
    const pageSize = parseInt(req.query.pageSize as string) || 20;
    const pageToken = req.query.pageToken as string;
    const filter = req.query.filter as string;
    
    // Validate pageSize
    if (pageSize <= 0 || pageSize > 100) {
      const errorResponse: McpErrorResponse = {
        code: 'MCP-4000',
        message: 'Invalid page size (must be between 1 and 100)',
        details: { pageSize }
      };
      res.status(400).json(errorResponse);
      return;
    }
    
    // Get all <%= resource.name.toLowerCase() %>s
    const all<%= resource.name %>s = Object.values(<%= resource.name.toLowerCase() %>Store);
    
    // Apply filtering (simplified implementation)
    let filtered<%= resource.name %>s = all<%= resource.name %>s;
    if (filter) {
      // This is a simplified filter implementation
      // In a real application, you would parse the filter string and apply it
      filtered<%= resource.name %>s = all<%= resource.name %>s.filter(<%= resource.name.toLowerCase() %> => 
        JSON.stringify(<%= resource.name.toLowerCase() %>).toLowerCase().includes(filter.toLowerCase())
      );
    }
    
    // Apply pagination
    let startIndex = 0;
    if (pageToken) {
      // In a real implementation, you would decode the page token
      // This is a simplified approach that assumes the page token is the start index
      startIndex = parseInt(pageToken);
      if (isNaN(startIndex)) {
        startIndex = 0;
      }
    }
    
    const endIndex = Math.min(startIndex + pageSize, filtered<%= resource.name %>s.length);
    const page<%= resource.name %>s = filtered<%= resource.name %>s.slice(startIndex, endIndex);
    
    // Generate next page token
    let nextPageToken: string | undefined;
    if (endIndex < filtered<%= resource.name %>s.length) {
      nextPageToken = String(endIndex);
    }
    
    // Create response
    const response: List<%= resource.name %>Response = {
      <%= resource.name.toLowerCase() %>s: page<%= resource.name %>s,
      nextPageToken,
      totalSize: filtered<%= resource.name %>s.length
    };
    
    // Return the response
    res.status(200).json(response);
  } catch (error) {
    console.error(\`Error listing <%= resource.name.toLowerCase() %>s:\`, error);
    const errorResponse: McpErrorResponse = {
      code: 'MCP-5000',
      message: 'Internal server error',
    };
    res.status(500).json(errorResponse);
  }
}

/**
 * Handler for creating a <%= resource.name %>.
 * @param req Express request
 * @param res Express response
 */
export async function create<%= resource.name %>(req: Request, res: Response): Promise<void> {
  try {
    const { <%= resource.name.toLowerCase() %> } = req.body as Create<%= resource.name %>Request;
    
    // Validate input
    if (!<%= resource.name.toLowerCase() %>) {
      const errorResponse: McpErrorResponse = {
        code: 'MCP-4000',
        message: 'Missing required <%= resource.name.toLowerCase() %> data',
      };
      res.status(400).json(errorResponse);
      return;
    }
    
    // Validate required fields
<% for (const field of resource.fields.filter(f => f.required && f.name !== 'id')) { %>
    if (!<%= resource.name.toLowerCase() %>.<%= field.name %>) {
      const errorResponse: McpErrorResponse = {
        code: 'MCP-4000',
        message: 'Missing required field: <%= field.name %>',
      };
      res.status(400).json(errorResponse);
      return;
    }
<% } %>
    
    // Generate a unique ID
    const id = uuidv4();
    
    // Create the <%= resource.name %>
    const new<%= resource.name %>: <%= resource.name %> = {
      id,
      ...<%= resource.name.toLowerCase() %>
    };
    
    // Save to store
    <%= resource.name.toLowerCase() %>Store[id] = new<%= resource.name %>;
    
    // Return the created <%= resource.name %>
    res.status(201).json(new<%= resource.name %>);
  } catch (error) {
    console.error(\`Error creating <%= resource.name.toLowerCase() %>:\`, error);
    const errorResponse: McpErrorResponse = {
      code: 'MCP-5000',
      message: 'Internal server error',
    };
    res.status(500).json(errorResponse);
  }
}

/**
 * Handler for updating a <%= resource.name %>.
 * @param req Express request
 * @param res Express response
 */
export async function update<%= resource.name %>(req: Request, res: Response): Promise<void> {
  try {
    const id = req.params.id;
    const { <%= resource.name.toLowerCase() %> } = req.body as Update<%= resource.name %>Request;
    
    // Validate input
    if (!id) {
      const errorResponse: McpErrorResponse = {
        code: 'MCP-4000',
        message: 'Missing required parameter: id',
      };
      res.status(400).json(errorResponse);
      return;
    }
    
    if (!<%= resource.name.toLowerCase() %>) {
      const errorResponse: McpErrorResponse = {
        code: 'MCP-4000',
        message: 'Missing required <%= resource.name.toLowerCase() %> data',
      };
      res.status(400).json(errorResponse);
      return;
    }
    
    // Get existing <%= resource.name %>
    const existing<%= resource.name %> = <%= resource.name.toLowerCase() %>Store[id];
    if (!existing<%= resource.name %>) {
      const errorResponse: McpErrorResponse = {
        code: 'MCP-4004',
        message: '<%= resource.name %> not found',
        details: { id }
      };
      res.status(404).json(errorResponse);
      return;
    }
    
    // Update the <%= resource.name %>
    const updated<%= resource.name %>: <%= resource.name %> = {
      ...existing<%= resource.name %>,
      ...<%= resource.name.toLowerCase() %>,
      id // Ensure ID doesn't change
    };
    
    // Save to store
    <%= resource.name.toLowerCase() %>Store[id] = updated<%= resource.name %>;
    
    // Return the updated <%= resource.name %>
    res.status(200).json(updated<%= resource.name %>);
  } catch (error) {
    console.error(\`Error updating <%= resource.name.toLowerCase() %>:\`, error);
    const errorResponse: McpErrorResponse = {
      code: 'MCP-5000',
      message: 'Internal server error',
    };
    res.status(500).json(errorResponse);
  }
}

/**
 * Handler for deleting a <%= resource.name %>.
 * @param req Express request
 * @param res Express response
 */
export async function delete<%= resource.name %>(req: Request, res: Response): Promise<void> {
  try {
    const id = req.params.id;
    
    // Validate input
    if (!id) {
      const errorResponse: McpErrorResponse = {
        code: 'MCP-4000',
        message: 'Missing required parameter: id',
      };
      res.status(400).json(errorResponse);
      return;
    }
    
    // Check if <%= resource.name %> exists
    if (!<%= resource.name.toLowerCase() %>Store[id]) {
      const errorResponse: McpErrorResponse = {
        code: 'MCP-4004',
        message: '<%= resource.name %> not found',
        details: { id }
      };
      res.status(404).json(errorResponse);
      return;
    }
    
    // Delete the <%= resource.name %>
    delete <%= resource.name.toLowerCase() %>Store[id];
    
    // Return success response
    const response: Delete<%= resource.name %>Response = {
      id,
      success: true
    };
    res.status(200).json(response);
  } catch (error) {
    console.error(\`Error deleting <%= resource.name.toLowerCase() %>:\`, error);
    const errorResponse: McpErrorResponse = {
      code: 'MCP-5000',
      message: 'Internal server error',
    };
    res.status(500).json(errorResponse);
  }
}`,
    'types.ejs': `// Generated by Axe Handle MCP Server Generator
// Date: <%= date %>
// Version: <%= version %>

// DO NOT EDIT THIS FILE MANUALLY
// This file contains TypeScript type definitions for the <%= service.name %> service

/**
 * Error response structure for MCP errors.
 */
export interface McpErrorResponse {
  /** Error code */
  code: string;
  /** Human-readable error message */
  message: string;
  /** Additional details about the error */
  details?: Record<string, unknown>;
}

<% for (const type of service.types) { %>
/**
 * <%= type.description %>
 */
export interface <%= type.name %> {
<% for (const field of type.fields) { %>
  /**
   * <%= field.description %>
   */
  <%= field.name %><%= field.required ? '' : '?' %>: <%= field.tsType %>;
<% } %>
}

<% } %>

// Request and Response Types
<% for (const resource of service.resources) { %>
  <% for (const operation of resource.operations) { %>
    <% if (operation.name === 'Get') { %>
/**
 * Request parameters for getting a <%= resource.name %> by ID.
 */
export interface <%= operation.inputType %> {
  /** ID of the <%= resource.name %> to retrieve */
  id: string;
}

    <% } else if (operation.name === 'List') { %>
/**
 * Request parameters for listing <%= resource.name.toLowerCase() %>s.
 */
export interface <%= operation.inputType %> {
  /** Maximum number of items to return (default: 20, max: 100) */
  pageSize?: number;
  /** Page token for pagination */
  pageToken?: string;
  /** Optional filter criteria */
  filter?: string;
}

/**
 * Response for listing <%= resource.name.toLowerCase() %>s.
 */
export interface <%= operation.outputType %> {
  /** List of <%= resource.name.toLowerCase() %>s */
  <%= resource.name.toLowerCase() %>s: <%= resource.name %>[];
  /** Token for retrieving the next page (if available) */
  nextPageToken?: string;
  /** Total count of <%= resource.name.toLowerCase() %>s matching the request */
  totalSize?: number;
}

    <% } else if (operation.name === 'Create') { %>
/**
 * Request parameters for creating a <%= resource.name %>.
 */
export interface <%= operation.inputType %> {
  /** <%= resource.name %> to create */
  <%= resource.name.toLowerCase() %>: Omit<<%= resource.name %>, 'id'>;
}

    <% } else if (operation.name === 'Update') { %>
/**
 * Request parameters for updating a <%= resource.name %>.
 */
export interface <%= operation.inputType %> {
  /** ID of the <%= resource.name %> to update */
  id: string;
  /** Updated <%= resource.name %> data */
  <%= resource.name.toLowerCase() %>: Partial<<%= resource.name %>>;
}

    <% } else if (operation.name === 'Delete') { %>
/**
 * Request parameters for deleting a <%= resource.name %>.
 */
export interface <%= operation.inputType %> {
  /** ID of the <%= resource.name %> to delete */
  id: string;
}

/**
 * Response for deleting a <%= resource.name %>.
 */
export interface <%= operation.outputType %> {
  /** ID of the deleted <%= resource.name %> */
  id: string;
  /** Whether the <%= resource.name %> was successfully deleted */
  success: boolean;
}
    <% } %>
  <% } %>

<% } %>`,
    'index.ejs': `// Generated by Axe Handle MCP Server Generator
// Date: <%= date %>
// Version: <%= version %>

// DO NOT EDIT THIS FILE MANUALLY
// This file contains the entry point for the <%= service.name %> MCP service

import app from './server';

const PORT = process.env.PORT || 3000;

// Start the server
app.listen(PORT, () => {
  console.log(\`<%= service.name %> MCP server is running on port \${PORT}\`);
  console.log(\`Health check: http://localhost:\${PORT}/health\`);
  
  // Log available endpoints
  console.log('\\nAvailable endpoints:');
<% for (const resource of service.resources) { %>
  console.log('\\n<%= resource.name %> Operations:');
<% for (const operation of resource.operations) { %>
  console.log(\`  \${operation.httpMethod} <%= operation.route %> - <%= operation.description %>\`);
<% } %>
<% } %>
});

// Handle termination signals
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully');
  process.exit(0);
});`,
    'api.ejs': `# <%= service.name %> API Documentation

> Generated by Axe Handle MCP Server Generator - <%= date %>

## Overview

This document describes the API for the <%= service.name %> service, which implements the Model Context Protocol (MCP).

## Base URL

\`\`\`
http://localhost:3000
\`\`\`

## Resources

<% for (const resource of service.resources) { %>
### <%= resource.name %>

<%= resource.description %>

#### Resource Structure

\`\`\`typescript
{
<% for (const field of resource.fields) { %>
  // <%= field.description %>
  "<%= field.name %>"<%= field.required ? '' : '?' %>: <%= field.tsType %>,
<% } %>
}
\`\`\`

#### Operations

<% for (const operation of resource.operations) { %>
##### <%= operation.description %>

\`\`\`
<%= operation.httpMethod %> <%= operation.route %>
\`\`\`

<% if (operation.name === 'Get') { %>
**Path Parameters:**

- \`id\` (string, required): ID of the <%= resource.name %> to retrieve

**Response:**

\`\`\`typescript
// On success (200 OK)
{
<% for (const field of resource.fields) { %>
  "<%= field.name %>"<%= field.required ? '' : '?' %>: <%= field.tsType %>,
<% } %>
}

// On error (4xx/5xx)
{
  "code": string,      // Error code (e.g., "MCP-4004")
  "message": string,   // Human-readable error message
  "details"?: object   // Additional error details
}
\`\`\`

<% } else if (operation.name === 'List') { %>
**Query Parameters:**

- \`pageSize\` (number, optional): Maximum number of items to return (default: 20, max: 100)
- \`pageToken\` (string, optional): Page token for pagination
- \`filter\` (string, optional): Filter criteria

**Response:**

\`\`\`typescript
// On success (200 OK)
{
  "<%= resource.name.toLowerCase() %>s": [
    {
<% for (const field of resource.fields) { %>
      "<%= field.name %>"<%= field.required ? '' : '?' %>: <%= field.tsType %>,
<% } %>
    },
    // ...
  ],
  "nextPageToken"?: string,  // Token for retrieving the next page
  "totalSize"?: number       // Total count of <%= resource.name.toLowerCase() %>s matching the request
}

// On error (4xx/5xx)
{
  "code": string,      // Error code (e.g., "MCP-4000")
  "message": string,   // Human-readable error message
  "details"?: object   // Additional error details
}
\`\`\`

<% } else if (operation.name === 'Create') { %>
**Request Body:**

\`\`\`typescript
{
  "<%= resource.name.toLowerCase() %>": {
<% for (const field of resource.fields.filter(f => f.name !== 'id')) { %>
    "<%= field.name %>"<%= field.required ? '' : '?' %>: <%= field.tsType %>,
<% } %>
  }
}
\`\`\`

**Response:**

\`\`\`typescript
// On success (201 Created)
{
<% for (const field of resource.fields) { %>
  "<%= field.name %>"<%= field.required ? '' : '?' %>: <%= field.tsType %>,
<% } %>
}

// On error (4xx/5xx)
{
  "code": string,      // Error code (e.g., "MCP-4000")
  "message": string,   // Human-readable error message
  "details"?: object   // Additional error details
}
\`\`\`

<% } else if (operation.name === 'Update') { %>
**Path Parameters:**

- \`id\` (string, required): ID of the <%= resource.name %> to update

**Request Body:**

\`\`\`typescript
{
  "<%= resource.name.toLowerCase() %>": {
<% for (const field of resource.fields.filter(f => f.name !== 'id')) { %>
    "<%= field.name %>"?: <%= field.tsType %>,  // Optional field to update
<% } %>
  }
}
\`\`\`

**Response:**

\`\`\`typescript
// On success (200 OK)
{
<% for (const field of resource.fields) { %>
  "<%= field.name %>"<%= field.required ? '' : '?' %>: <%= field.tsType %>,
<% } %>
}

// On error (4xx/5xx)
{
  "code": string,      // Error code (e.g., "MCP-4004")
  "message": string,   // Human-readable error message
  "details"?: object   // Additional error details
}
\`\`\`

<% } else if (operation.name === 'Delete') { %>
**Path Parameters:**

- \`id\` (string, required): ID of the <%= resource.name %> to delete

**Response:**

\`\`\`typescript
// On success (200 OK)
{
  "id": string,     // ID of the deleted <%= resource.name %>
  "success": boolean  // Whether the <%= resource.name %> was successfully deleted
}

// On error (4xx/5xx)
{
  "code": string,      // Error code (e.g., "MCP-4004")
  "message": string,   // Human-readable error message
  "details"?: object   // Additional error details
}
\`\`\`
<% } %>

<% } %>

<% } %>

## Error Codes

The API uses the following error codes:

- \`MCP-4000\`: Bad Request - The request is malformed or contains invalid parameters
- \`MCP-4004\`: Not Found - The requested resource does not exist
- \`MCP-5000\`: Internal Server Error - An unexpected error occurred on the server

## Additional Notes

- All endpoints return JSON responses
- Authentication is not implemented in this generated code
- All date/time fields use ISO 8601 format (e.g., "2023-10-25T15:30:00Z")
`
};
// Create express subdirectory
const expressDir = path.join(templatesDir, 'express');
if (!fs.existsSync(expressDir)) {
    console.log('Creating express templates directory...');
    fs.mkdirSync(expressDir, { recursive: true });
}
// Create essential template subdirectories
const categories = ['server', 'handler', 'types', 'index', 'api'];
for (const category of categories) {
    const categoryDir = path.join(expressDir, category);
    if (!fs.existsSync(categoryDir)) {
        console.log(`Creating directory: ${categoryDir}`);
        fs.mkdirSync(categoryDir, { recursive: true });
    }
}
// Create template files
for (const [name, content] of Object.entries(essentialTemplates)) {
    // Save in the root templates directory
    const filePath = path.join(templatesDir, name);
    if (!fs.existsSync(filePath)) {
        console.log(`Creating template: ${filePath}`);
        fs.writeFileSync(filePath, content);
    }
    else {
        console.log(`Template already exists: ${filePath}`);
    }
    // Also save in the appropriate express subdirectory
    const category = name.split('.')[0]; // e.g., 'server' from 'server.ejs'
    const expressFilePath = path.join(expressDir, category, name);
    const categoryDir = path.dirname(expressFilePath);
    if (!fs.existsSync(categoryDir)) {
        console.log(`Creating directory: ${categoryDir}`);
        fs.mkdirSync(categoryDir, { recursive: true });
    }
    if (!fs.existsSync(expressFilePath)) {
        console.log(`Creating express template: ${expressFilePath}`);
        fs.writeFileSync(expressFilePath, content);
    }
    else {
        console.log(`Express template already exists: ${expressFilePath}`);
    }
}
// Check generator implementation
console.log('\nChecking generator implementation...');
try {
    const generatorPath = path.join(__dirname, '..', 'generator', 'mcpServerGenerator.ts');
    console.log(`Generator path: ${generatorPath}`);
    if (fs.existsSync(generatorPath)) {
        const generatorContent = fs.readFileSync(generatorPath, 'utf-8');
        console.log('Generator file exists. Checking for templatesDir initialization...');
        // Look for where the templatesDir is initialized
        const templateDirMatch = generatorContent.match(/this\.templatesDir\s*=\s*([^;]+)/);
        if (templateDirMatch) {
            console.log(`Found templatesDir initialization: ${templateDirMatch[0]}`);
            // Check if it's using path.resolve correctly
            if (!templateDirMatch[1].includes('path.resolve') || !templateDirMatch[1].includes('templates')) {
                console.log('WARNING: The templatesDir initialization may be incorrect. Consider updating it to:');
                console.log(`this.templatesDir = path.resolve(__dirname, '../../templates');`);
            }
        }
        else {
            console.log('WARNING: Could not find templatesDir initialization in mcpServerGenerator.ts');
        }
    }
    else {
        console.log(`WARNING: Generator file not found at ${generatorPath}`);
    }
}
catch (err) {
    console.error('Error checking generator implementation:', err);
}
console.log('\nTemplate setup complete!');
//# sourceMappingURL=setupTemplates.js.map